<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Callback Listener - Requests</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/static/style.css">
</head>
<body>
  <header class="topbar">
    <div class="container topbar-inner">
      <div class="brand">Callback Listener</div>
      <nav class="nav">
        <a class="active" href="/">Requests</a>
        <a href="/rules">Rules</a>
        <a href="/settings">Settings</a>
        <a href="/healthz">Health</a>
      </nav>
    </div>
  </header>

  <section class="hero">
    <div class="container">
      <h1>Incoming calls, logged with context.</h1>
      <p>Listening on <span class="badge">/hook/*</span> with full payload capture.</p>
    </div>
  </section>

  <main class="container">
    <div class="card">
      <div class="card-header">
        <div>
          <h2>Latest requests</h2>
          <p class="hint">Most recent 50 calls. Click any row for details.</p>
        </div>
        <div class="card-actions">
          <form class="filter" action="/" method="get">
            <label for="path-filter">Path</label>
            <input id="path-filter" name="path" list="path-options" placeholder="All" value="{{ .Active }}">
            <button class="button ghost" type="submit">Filter</button>
            {{ if .Active }}
              <a class="link" href="/">Clear</a>
            {{ end }}
          </form>
          <div class="chip" id="live-status">Live</div>
        </div>
      </div>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>ID</th>
              <th>Method</th>
              <th>Path</th>
              <th>Received</th>
              <th>Rule</th>
            </tr>
          </thead>
          <tbody>
            {{ if .Requests }}
              {{ range .Requests }}
                <tr class="request-row" data-request-id="{{ .ID }}">
                  <td><a class="link" href="/requests/{{ .ID }}">#{{ .ID }}</a></td>
                  <td><span class="method m-{{ .Method }}">{{ .Method }}</span></td>
                  <td class="mono">{{ .Path }}</td>
                  <td>{{ formatTime .CreatedAt }}</td>
                  <td>
                    {{ if .RuleID.Valid }}
                      <a class="link" href="/rules/{{ .RuleID.Int64 }}/edit">Rule {{ .RuleID.Int64 }}</a>
                    {{ else }}
                      <span class="muted">None</span>
                    {{ end }}
                  </td>
                </tr>
              {{ end }}
            {{ else }}
              <tr>
                <td class="empty" colspan="5">
                  {{ if .Active }}
                    No requests for <span class="mono">{{ .Active }}</span> yet.
                  {{ else }}
                    No requests yet. Send a call to /hook/your-endpoint.
                  {{ end }}
                </td>
              </tr>
            {{ end }}
          </tbody>
        </table>
      </div>
    </div>
    <datalist id="path-options">
      {{ range .Paths }}
        <option value="{{ . }}"></option>
      {{ end }}
    </datalist>
  </main>
  <script>
    const refreshMs = 5000;
    const activePath = new URLSearchParams(window.location.search).get("path") || "";
    const tableBody = document.querySelector("tbody");
    const liveStatus = document.getElementById("live-status");

    function formatClock() {
      return new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" });
    }

    function renderEmptyRow(pathValue) {
      const row = document.createElement("tr");
      const cell = document.createElement("td");
      cell.className = "empty";
      cell.colSpan = 5;
      if (pathValue) {
        const span = document.createElement("span");
        span.className = "mono";
        span.textContent = pathValue;
        cell.append("No requests for ", span, " yet.");
      } else {
        cell.textContent = "No requests yet. Send a call to /hook/your-endpoint.";
      }
      row.appendChild(cell);
      return row;
    }

    function renderRows(items) {
      tableBody.innerHTML = "";
      if (!items.length) {
        tableBody.appendChild(renderEmptyRow(activePath));
        return;
      }

      for (const item of items) {
        const row = document.createElement("tr");
        row.className = "request-row";
        row.dataset.requestId = item.id;

        const idCell = document.createElement("td");
        const idLink = document.createElement("a");
        idLink.className = "link";
        idLink.href = `/requests/${item.id}`;
        idLink.textContent = `#${item.id}`;
        idCell.appendChild(idLink);
        row.appendChild(idCell);

        const methodCell = document.createElement("td");
        const methodTag = document.createElement("span");
        methodTag.className = `method m-${item.method}`;
        methodTag.textContent = item.method;
        methodCell.appendChild(methodTag);
        row.appendChild(methodCell);

        const pathCell = document.createElement("td");
        pathCell.className = "mono";
        pathCell.textContent = item.path;
        row.appendChild(pathCell);

        const timeCell = document.createElement("td");
        timeCell.textContent = item.created_at;
        row.appendChild(timeCell);

        const ruleCell = document.createElement("td");
        if (item.rule_id) {
          const ruleLink = document.createElement("a");
          ruleLink.className = "link";
          ruleLink.href = `/rules/${item.rule_id}/edit`;
          ruleLink.textContent = `Rule ${item.rule_id}`;
          ruleCell.appendChild(ruleLink);
        } else {
          const muted = document.createElement("span");
          muted.className = "muted";
          muted.textContent = "None";
          ruleCell.appendChild(muted);
        }
        row.appendChild(ruleCell);

        tableBody.appendChild(row);
      }
    }

    const detailCache = new Map();
    let expandedId = null;

    function formatJSON(raw) {
      if (!raw) {
        return "";
      }
      try {
        return JSON.stringify(JSON.parse(raw), null, 2);
      } catch (error) {
        return raw;
      }
    }

    function createDetailSection(title, contentNode) {
      const card = document.createElement("div");
      card.className = "detail-card";
      const heading = document.createElement("h3");
      heading.textContent = title;
      card.appendChild(heading);
      card.appendChild(contentNode);
      return card;
    }

    function createMuted(text) {
      const div = document.createElement("div");
      div.className = "muted";
      div.textContent = text;
      return div;
    }

    function createPreformatted(text) {
      const pre = document.createElement("pre");
      pre.textContent = text;
      return pre;
    }

    function buildDetailRow(detail) {
      const detailRow = document.createElement("tr");
      detailRow.className = "detail-row";
      const cell = document.createElement("td");
      cell.colSpan = 5;

      const panel = document.createElement("div");
      panel.className = "detail-panel";
      const grid = document.createElement("div");
      grid.className = "detail-grid two-col";

      const headersContent = detail.headers_json
        ? createPreformatted(formatJSON(detail.headers_json))
        : createMuted("No headers captured.");
      grid.appendChild(createDetailSection("Headers", headersContent));

      const bodyContent = detail.body_text
        ? createPreformatted(formatJSON(detail.body_text))
        : createMuted("No body content.");
      grid.appendChild(createDetailSection("Body", bodyContent));

      panel.appendChild(grid);
      cell.appendChild(panel);
      detailRow.appendChild(cell);
      return detailRow;
    }

    function clearExpandedRow() {
      const detailRow = tableBody.querySelector(".detail-row");
      if (detailRow) {
        detailRow.remove();
      }
      const openRow = tableBody.querySelector(".request-row.is-open");
      if (openRow) {
        openRow.classList.remove("is-open");
      }
    }

    async function fetchDetail(id) {
      if (detailCache.has(id)) {
        return detailCache.get(id);
      }
      const response = await fetch(`/api/requests/${id}`, { headers: { Accept: "application/json" } });
      if (!response.ok) {
        throw new Error("Failed to load request detail");
      }
      const detail = await response.json();
      detailCache.set(id, detail);
      return detail;
    }

    async function showDetail(id) {
      const row = tableBody.querySelector(`tr[data-request-id="${id}"]`);
      if (!row) {
        expandedId = null;
        clearExpandedRow();
        return;
      }
      clearExpandedRow();
      expandedId = id;
      row.classList.add("is-open");
      try {
        const detail = await fetchDetail(id);
        const detailRow = buildDetailRow(detail);
        row.insertAdjacentElement("afterend", detailRow);
      } catch (error) {
        expandedId = null;
        row.classList.remove("is-open");
      }
    }

    tableBody.addEventListener("click", (event) => {
      const link = event.target.closest("a");
      if (link) {
        return;
      }
      const row = event.target.closest("tr[data-request-id]");
      if (!row) {
        return;
      }
      const id = Number(row.dataset.requestId);
      if (!id) {
        return;
      }
      if (expandedId === id) {
        expandedId = null;
        clearExpandedRow();
        return;
      }
      showDetail(id);
    });

    async function refreshRequests() {
      if (document.visibilityState !== "visible") {
        return;
      }
      try {
        const url = new URL("/api/requests", window.location.origin);
        if (activePath) {
          url.searchParams.set("path", activePath);
        }
        const response = await fetch(url, { headers: { Accept: "application/json" } });
        if (!response.ok) {
          return;
        }
        const items = await response.json();
        renderRows(items);
        if (liveStatus) {
          liveStatus.textContent = `Live Â· ${formatClock()}`;
        }
        if (expandedId) {
          showDetail(expandedId);
        }
      } catch (error) {
        // Silent fail to avoid flashing errors in the UI.
      }
    }

    setInterval(refreshRequests, refreshMs);
  </script>
</body>
</html>
